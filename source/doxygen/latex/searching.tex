Doxygen indexes your source code in various ways to make it easier to navigate and find what you are looking for. There are also situations however where you want to search for something by keyword rather than browse for it.

H\+T\+ML browsers by default have no search capabilities that work across multiple pages, so either doxygen or external tools need to help to facilitate this feature.

Doxygen has 7 different ways to add searching to the H\+T\+ML output, each of which has its own advantages and disadvantages\+:

\doxysubsection*{1. Client side searching}

The easiest way to enable searching is to enable the built-\/in client side search engine. This engine is implemented using Java\+Script and D\+H\+T\+ML only and runs entirely on the clients browser. So no additional tooling is required to make it work.

To enable it set S\+E\+A\+R\+C\+H\+E\+N\+G\+I\+NE to {\ttfamily Y\+ES} in the configuration file and make sure S\+E\+R\+V\+E\+R\+\_\+\+B\+A\+S\+E\+D\+\_\+\+S\+E\+A\+R\+CH is set to {\ttfamily NO}.

An additional advantage of this method is that it provides live searching, i.\+e. the search results are presented and adapted as you type.

This method also has its drawbacks\+: it is limited to searching for symbols only. It does not provide full text search capabilities and it does not scale well to very large projects (then searching becomes very slow). Furthermore the searching is done from the beginning of the indexed items, so when having the available items {\ttfamily A\+\_\+\+S\+T\+R\+I\+NG}, {\ttfamily A\+A\+\_\+\+S\+T\+R\+I\+NG} and {\ttfamily S\+T\+R\+I\+NG} and typing in the search box {\ttfamily A} it will find {\ttfamily A\+\_\+\+S\+T\+R\+I\+NG} and {\ttfamily A\+A\+\_\+\+S\+T\+R\+I\+NG}, but when typing e.\+g. {\ttfamily S\+TR} it will only find {\ttfamily S\+T\+R\+I\+NG} and not {\ttfamily A\+\_\+\+S\+T\+R\+I\+NG}.

\doxysubsection*{2. Server side searching}

If you plan to put the H\+T\+ML documentation on a web server, and that web server has the capability to process P\+HP code, then you can also use doxygen\textquotesingle{}s built-\/in server side search engine.

To enable this set both S\+E\+A\+R\+C\+H\+E\+N\+G\+I\+NE and S\+E\+R\+V\+E\+R\+\_\+\+B\+A\+S\+E\+D\+\_\+\+S\+E\+A\+R\+CH to {\ttfamily Y\+ES} in the configuration file and set E\+X\+T\+E\+R\+N\+A\+L\+\_\+\+S\+E\+A\+R\+CH to {\ttfamily NO}.

Advantages over the client side search engine are that it provides full text search and it scales well to medium side projects.

Disadvantages are that it does not work locally (i.\+e. using a \char`\"{}file\+://\char`\"{} U\+RL) and that it does not provide live search capabilities.

\begin{DoxyNote}{Note}
In the future this option will probably be replaced by the next search option.
\end{DoxyNote}
\doxysubsection*{3. Server side searching with external indexing}

With release 1.\+8.\+3 of doxygen, another server based search option has been added. With this option doxygen generates the raw data that can be searched and leaves it up to external tools to do the indexing and searching, meaning that you could use your own indexer and search engine of choice. To make life easier doxygen ships with an example indexer (doxyindexer) and search engine (doxysearch.\+cgi) based on the \href{https://xapian.org/}{\texttt{ Xapian}} open source search engine library.

To enable this search method set S\+E\+A\+R\+C\+H\+E\+N\+G\+I\+NE, S\+E\+R\+V\+E\+R\+\_\+\+B\+A\+S\+E\+D\+\_\+\+S\+E\+A\+R\+CH and E\+X\+T\+E\+R\+N\+A\+L\+\_\+\+S\+E\+A\+R\+CH all to {\ttfamily Y\+ES}.

See \mbox{\hyperlink{extsearch}{External Indexing and Searching}} for configuration details.

Advantages over option 2 are that this method (potentially) scales to very large projects. It is also possible to combine multiple doxygen projects and external data into one search index. The way the interaction with the search engine is done, makes it possible to search from local H\+T\+ML pages. Also the search results have better ranking and show context information (if available).

Disadvantages are that is requires a web server that can execute a C\+GI binary, and an additional indexing step after running doxygen.

\doxysubsection*{4. Windows Compiled H\+T\+ML Help}

If you are running doxygen on Windows, then you can make a compiled H\+T\+ML Help file (.chm) out of the H\+T\+ML files produced by doxygen. This is a single file containing all H\+T\+ML files and it also includes a search index. There are viewers for this format on many platforms, and Windows even supports it natively.

To enable this set G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+H\+T\+M\+L\+H\+E\+LP to {\ttfamily Y\+ES} in the configuration file. To let doxygen compile the H\+T\+ML Help file for you, you also need to specify the path to the H\+T\+ML compiler (hhc.\+exe) using the H\+H\+C\+\_\+\+L\+O\+C\+A\+T\+I\+ON configuration option and the name of the resulting C\+HM file using C\+H\+M\+\_\+\+F\+I\+LE.

An advantage of this method is that the result is a single file that can easily be distributed. It also provides full text search.

Disadvantages are that compiling the C\+HM file only works on Windows and requires Microsoft\textquotesingle{}s H\+T\+ML compiler, which is not very actively supported by Microsoft. Although the tool works fine for most people, it can sometimes crash for no apparent reason (how typical).

\doxysubsection*{5. Mac OS X Doc Sets}

If you are running doxygen on Mac OS X 10.\+5 or higher, then you can make a \char`\"{}doc set\char`\"{} out of the H\+T\+ML files produced by doxygen. A doc set consists of a single directory with a special structure containing the H\+T\+ML files along with a precompiled search index. A doc set can be embedded in Xcode (the integrated development environment provided by Apple).

To enable the creation of doc sets set G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+D\+O\+C\+S\+ET to {\ttfamily Y\+ES} in the configuration file. There are a couple of other doc set related options you may want to set. After doxygen has finished you will find a Makefile in the H\+T\+ML output directory. Running \char`\"{}make install\char`\"{} on this Makefile will compile and install the doc set. See \href{https://developer.apple.com/library/archive/featuredarticles/DoxygenXcode/_index.html}{\texttt{ this article}} for more info.

Advantage of this method is that it nicely integrates with the Xcode development environment, allowing for instance to click on an identifier in the editor and jump to the corresponding section in the doxygen documentation.

Disadvantage is that it only works in combination with Xcode on Mac\+O\+SX.

\doxysubsection*{6. Qt Compressed Help}

If you develop for or want to install the Qt application framework, you will get an application called \href{https://doc.qt.io/archives/qt-4.8/assistant-manual.html}{\texttt{ Qt assistant}}. This is a help viewer for Qt Compressed Help files ({\ttfamily .qch}).

To enable this feature set G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+Q\+HP to {\ttfamily Y\+ES}. You also need to fill in the other Qt help related options, such as Q\+H\+P\+\_\+\+N\+A\+M\+E\+S\+P\+A\+CE, Q\+H\+G\+\_\+\+L\+O\+C\+A\+T\+I\+ON, Q\+H\+P\+\_\+\+V\+I\+R\+T\+U\+A\+L\+\_\+\+F\+O\+L\+D\+ER. See \href{https://doc.qt.io/archives/qq/qq28-qthelp.html\#htmlfilesandhelpprojects}{\texttt{ this article}} for more info.

Feature wise the Qt compressed help feature is comparable with the C\+HM output, with the additional advantage that compiling the Q\+CH file is not limited to Windows.

Disadvantage is that it requires setting up a Qt 4.\+5 (or better) for each user, or distributing the Qt help assistant along with the documentation, which is complicated by the fact that it is not available as a separate package at this moment.

\doxysubsection*{7. Eclipse Help Plugin}

If you use eclipse, you can embed the documentation generated by doxygen as a help plugin. It will then appear as a topic in the help browser that can be started from \char`\"{}\+Help contents\char`\"{} in the Help menu. Eclipse will generate a search index for the documentation when you first search for a keyword.

To enable the help plugin set G\+E\+N\+E\+R\+A\+T\+E\+\_\+\+E\+C\+L\+I\+P\+S\+E\+H\+E\+LP to {\ttfamily Y\+ES}, and define a unique identifier for your project via E\+C\+L\+I\+P\+S\+E\+\_\+\+D\+O\+C\+\_\+\+ID, i.\+e.\+: \begin{DoxyVerb}   GENERATE_ECLIPSEHELP = YES
   ECLIPSE_DOC_ID       = com.yourcompany.yourproject
\end{DoxyVerb}
 then create the {\ttfamily com.\+yourcompany.\+yourproject} directory (so with the same name as the value of {\ttfamily E\+C\+L\+I\+P\+S\+E\+\_\+\+D\+O\+C\+\_\+\+ID}) in the {\ttfamily plugin} directory of eclipse and after doxygen completes copy to contents of the help output directory to the {\ttfamily com.\+yourcompany.\+yourproject} directory. Then restart eclipse to make let it find the new plugin.

The eclipse help plugin provides similar functionality as the Qt compressed help or C\+HM output, but it does require that Eclipse is installed and running.

 \hypertarget{extsearch}{}\doxysection{External Indexing and Searching}\label{extsearch}
\hypertarget{extsearch_extsearch_intro}{}\doxysubsection{Introduction}\label{extsearch_extsearch_intro}
With release 1.\+8.\+3, doxygen provides the ability to search through H\+T\+ML using an external indexing tool and search engine. This has several advantages\+:
\begin{DoxyItemize}
\item For large projects it can have significant performance advantages over doxygen\textquotesingle{}s built-\/in search engine, as doxygen uses a rather simple indexing algorithm.
\item It allows combining the search data of multiple projects into one index, allowing a global search across multiple doxygen projects.
\item It allows adding additional data to the search index, i.\+e. other web pages not produced by doxygen.
\item The search engine needs to run on a web server, but clients can still browse the web pages locally.
\end{DoxyItemize}

To avoid that everyone has to start writing their own indexer and search engine, doxygen provides an example tool for each action\+: {\ttfamily doxyindexer} for indexing the data and {\ttfamily doxysearch.\+cgi} for searching through the index.

The data flow is shown in the following diagram\+:

 
\begin{DoxyImage}
\includegraphics[height=10cm]{extsearch_flow}
\doxyfigcaption{External Search Data Flow}
\end{DoxyImage}



\begin{DoxyItemize}
\item {\ttfamily doxygen} produces the raw search data
\item {\ttfamily doxyindexer} indexes the data into a search database {\ttfamily doxysearch.\+db}
\item when a user performs a search from a doxygen generated H\+T\+ML page, the C\+GI binary {\ttfamily doxysearch.\+cgi} will be invoked.
\item the {\ttfamily doxysearch.\+cgi} tool will perform a query on the database and return the results.
\item The browser will show the search results.
\end{DoxyItemize}\hypertarget{extsearch_extsearch_config}{}\doxysubsection{Configuring}\label{extsearch_extsearch_config}
The first step is to make the search engine available via a web server. If you use {\ttfamily doxysearch.\+cgi} this means making the \href{https://en.wikipedia.org/wiki/Common_Gateway_Interface}{\texttt{ C\+GI}} binary available from the web server (i.\+e. be able to run it from a browser via an U\+RL starting with http\+:)

How to setup a web server is outside the scope of this document, but if you for instance have Apache installed, you could simply copy the {\ttfamily doxysearch.\+cgi} file from doxygen\textquotesingle{}s {\ttfamily bin} directory to the {\ttfamily cgi-\/bin} directory of the Apache web server. Read the \href{http://httpd.apache.org/docs/2.2/howto/cgi.html}{\texttt{ apache documentation}} for details.

To test if {\ttfamily doxysearch.\+cgi} is accessible start your web browser and point to U\+RL to the binary and add {\ttfamily ?test} at the end \begin{DoxyVerb}http://yoursite.com/path/to/cgi/doxysearch.cgi?test
\end{DoxyVerb}


You should get the following message\+: \begin{DoxyVerb}Test failed: cannot find search index doxysearch.db
\end{DoxyVerb}


If you use Internet Explorer you may be prompted to download a file, which will then contain this message.

Since we didn\textquotesingle{}t create or install a doxysearch.\+db it is OK for the test to fail for this reason. How to correct this is discussed in the next section.

Before continuing with the next section add the above U\+RL (without the {\ttfamily ?test} part) to the S\+E\+A\+R\+C\+H\+E\+N\+G\+I\+N\+E\+\_\+\+U\+RL tag in doxygen\textquotesingle{}s configuration file\+: \begin{DoxyVerb}SEARCHENGINE_URL = http://yoursite.com/path/to/cgi/doxysearch.cgi
\end{DoxyVerb}
\hypertarget{extsearch_extsearch_single}{}\doxysubsubsection{Single project index}\label{extsearch_extsearch_single}
To use the external search option, make sure the following options are enabled in doxygen\textquotesingle{}s configuration file\+: \begin{DoxyVerb}SEARCHENGINE           = YES
SERVER_BASED_SEARCH    = YES
EXTERNAL_SEARCH        = YES
\end{DoxyVerb}


This will make doxygen generate a file called {\ttfamily searchdata.\+xml} in the output directory (configured with O\+U\+T\+P\+U\+T\+\_\+\+D\+I\+R\+E\+C\+T\+O\+RY). You can change the file name (and location) with the S\+E\+A\+R\+C\+H\+D\+A\+T\+A\+\_\+\+F\+I\+LE option.

The next step is to put the raw search data into an index for efficient searching. You can use {\ttfamily doxyindexer} for this. Simply run it from the command line\+: \begin{DoxyVerb}doxyindexer searchdata.xml
\end{DoxyVerb}


This will create a directory called {\ttfamily doxysearch.\+db} with some files in it. By default the directory will be created at the location from which doxyindexer was started, but you can change the directory using the {\ttfamily -\/o} option.

Copy the {\ttfamily doxysearch.\+db} directory to the same directory as where the {\ttfamily doxysearch.\+cgi} is located and rerun the browser test by pointing the browser to \begin{DoxyVerb}http://yoursite.com/path/to/cgi/doxysearch.cgi?test
\end{DoxyVerb}


You should now get the following message\+: \begin{DoxyVerb}Test successful.
\end{DoxyVerb}


Now you should be able to search for words and symbols from the H\+T\+ML output.\hypertarget{extsearch_extsearch_multi}{}\doxysubsubsection{Multi project index}\label{extsearch_extsearch_multi}
In case you have more than one doxygen project and these projects are related, it may be desirable to allow searching for words in all projects from within the documentation of any of the projects.

To make this possible all that is needed is to combine the search data for all projects into a single index, e.\+g. for two projects A and B for which the searchdata.\+xml is generated in directories project\+\_\+A and project\+\_\+B run\+: \begin{DoxyVerb}doxyindexer project_A/searchdata.xml project_B/searchdata.xml
\end{DoxyVerb}


and then copy the resulting {\ttfamily doxysearch.\+db} to the directory where also {\ttfamily doxysearch.\+cgi} is located.

The {\ttfamily searchdata.\+xml} file doesn\textquotesingle{}t contain any absolute paths or links, so how can the search results from multiple projects be linked back to the right documentation set? This is where the E\+X\+T\+E\+R\+N\+A\+L\+\_\+\+S\+E\+A\+R\+C\+H\+\_\+\+ID and E\+X\+T\+R\+A\+\_\+\+S\+E\+A\+R\+C\+H\+\_\+\+M\+A\+P\+P\+I\+N\+GS options come into play.

To be able to identify the different projects, one needs to set a unique ID using E\+X\+T\+E\+R\+N\+A\+L\+\_\+\+S\+E\+A\+R\+C\+H\+\_\+\+ID for each project.

To link the search results to the right project, you need to define a mapping per project using the E\+X\+T\+R\+A\+\_\+\+S\+E\+A\+R\+C\+H\+\_\+\+M\+A\+P\+P\+I\+N\+GS tag. With this option to can define the mapping from I\+Ds of other projects to the (relative) location of documentation of those projects.

So for projects A and B the relevant part of the configuration file could look as follows\+: \begin{DoxyVerb}project_A/Doxyfile
------------------
EXTERNAL_SEARCH_ID    = A
EXTRA_SEARCH_MAPPINGS = B=../../project_B/html
\end{DoxyVerb}


for project A and for project B \begin{DoxyVerb}project_B/Doxyfile
------------------
EXTERNAL_SEARCH_ID    = B
EXTRA_SEARCH_MAPPINGS = A=../../project_A/html
\end{DoxyVerb}


with these settings, projects A and B can share the same search database, and the search results will link to the right documentation set.\hypertarget{extsearch_extsearch_update}{}\doxysubsection{Updating the index}\label{extsearch_extsearch_update}
When you modify the source code, you should re-\/run doxygen to get up to date documentation again. When using external searching you also need to update the search index by re-\/running {\ttfamily doxyindexer}. You could wrap the call to {\ttfamily doxygen} and {\ttfamily doxyindexer} together in a script to make this process easier.\hypertarget{extsearch_extsearch_api}{}\doxysubsection{Programming interface}\label{extsearch_extsearch_api}
Previous sections have assumed you use the tools {\ttfamily doxyindexer} and {\ttfamily doxysearch.\+cgi} to do the indexing and searching, but you could also write your own index and search tools if you like.

For this 3 interfaces are important
\begin{DoxyItemize}
\item The format of the input for the index tool.
\item The format of the input for the search engine.
\item The format of the output of search engine.
\end{DoxyItemize}

The next subsections describe these interfaces in more detail.\hypertarget{extsearch_extsearch_api_index}{}\doxysubsubsection{Indexer input format}\label{extsearch_extsearch_api_index}
The search data produced by doxygen follows the \href{https://cwiki.apache.org/confluence/display/solr/UpdateXmlMessages}{\texttt{ Solr X\+ML index message}} format.

The input for the indexer is an X\+ML file, which consists of one {\ttfamily $<$add$>$} tag containing multiple {\ttfamily $<$doc$>$} tags, which in turn contain multiple {\ttfamily $<$field$>$} tags.

Here is an example of one doc node, which contains the search data and meta data for one method\+: \begin{DoxyVerb}<add>
  ...
  <doc>
    <field name="type">function</field>
    <field name="name">QXmlReader::setDTDHandler</field>
    <field name="args">(QXmlDTDHandler *handler)=0</field>
    <field name="tag">qtools.tag</field>
    <field name="url">de/df6/class_q_xml_reader.html#a0b24b1fe26a4c32a8032d68ee14d5dba</field>
    <field name="keywords">setDTDHandler QXmlReader::setDTDHandler QXmlReader</field>
    <field name="text">Sets the DTD handler to handler DTDHandler()</field>
  </doc>
  ...
</add>
\end{DoxyVerb}


Each field has a name. The following field names are supported\+:
\begin{DoxyItemize}
\item {\itshape type}\+: the type of the search entry; can be one of\+: source, function, slot, signal, variable, typedef, enum, enumvalue, property, event, related, friend, define, file, namespace, group, package, page, dir
\item {\itshape name}\+: the name of the search entry; for a method this is the qualified name of the method, for a class it is the name of the class, etc.
\item {\itshape args}\+: the parameter list (in case of functions or methods)
\item {\itshape tag}\+: the name of the tag file used for this project.
\item {\itshape url}\+: the (relative) U\+RL to the H\+T\+ML documentation for this entry.
\item {\itshape keywords}\+: important words that are representative for the entry. When searching for such keyword, this entry should get a higher rank in the search results.
\item {\itshape text}\+: the documentation associated with the item. Note that only words are present, no markup.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Due to the potentially large size of the X\+ML file, it is recommended to use a \href{https://en.wikipedia.org/wiki/Simple_API_for_XML}{\texttt{ S\+AX based parser}} to process it.
\end{DoxyNote}
\hypertarget{extsearch_extsearch_api_search_in}{}\doxysubsubsection{Search U\+R\+L format}\label{extsearch_extsearch_api_search_in}
When the search engine is invoked from a doxygen generated H\+T\+ML page, a number of parameters are passed to via the \href{https://en.wikipedia.org/wiki/Query_string}{\texttt{ query string}}.

The following fields are passed\+:
\begin{DoxyItemize}
\item {\itshape q}\+: the query text as entered by the user
\item {\itshape n}\+: the number of search results requested.
\item {\itshape p}\+: the number of search page for which to return the results. Each page has {\itshape n} values.
\item {\itshape cb}\+: the name of the callback function, used for J\+S\+ON with padding, see the next section.
\end{DoxyItemize}

From the complete list of search results, the range {\ttfamily \mbox{[}n$\ast$p -\/ n$\ast$(p+1)-\/1\mbox{]}} should be returned.

Here is an example of how a query looks like. \begin{DoxyVerb}http://yoursite.com/path/to/cgi/doxysearch.cgi?q=list&n=20&p=1&cb=dummy
\end{DoxyVerb}


It represents a query for the word \textquotesingle{}list\textquotesingle{} ({\ttfamily q=list}) requesting 20 search results ({\ttfamily n=20}), starting with the result number 20 ({\ttfamily p=1}) and using callback \textquotesingle{}dummy\textquotesingle{} ({\ttfamily cb=dummy})\+:

\begin{DoxyNote}{Note}
The values are \href{https://en.wikipedia.org/wiki/Percent-encoding}{\texttt{ U\+RL encoded}} so they have to be decoded before they can be used.
\end{DoxyNote}
\hypertarget{extsearch_extsearch_api_search_out}{}\doxysubsubsection{Search results format}\label{extsearch_extsearch_api_search_out}
When invoking the search engine as shown in the previous subsection, it should reply with the results. The format of the reply is \href{https://en.wikipedia.org/wiki/JSONP}{\texttt{ J\+S\+ON with padding}}, which is basically a javascript struct wrapped in a function call. The name of function should be the name of the callback (as passed with the {\itshape cb} field in the query).

With the example query as shown the previous subsection the main structure of the reply should look as follows\+: \begin{DoxyVerb}dummy({
  "hits":179,
  "first":20,
  "count":20,
  "page":1,
  "pages":9,
  "query": "list",
  "items":[
  ...
 ]})
\end{DoxyVerb}


The fields have the following meaning\+:
\begin{DoxyItemize}
\item {\itshape hits}\+: the total number of search results (could be more than was requested).
\item {\itshape first}\+: the index of first result returned\+: $\min(n*p,\mbox{\em hits})$.
\item {\itshape count}\+: the actual number of results returned\+: $\min(n,\mbox{\em hits}-\mbox{\em first})$
\item {\itshape page}\+: the page number of the result\+: $p$
\item {\itshape pages}\+: the total number of pages\+: $\lceil\frac{\mbox{\em hits}}{n}\rceil$.
\item {\itshape items}\+: an array containing the search data per result.
\end{DoxyItemize}

Here is an example of how the element of the {\itshape items} array should look like\+: \begin{DoxyVerb}{"type": "function",
 "name": "QDir::entryInfoList(const QString &nameFilter, int filterSpec=DefaultFilter, int sortSpec=DefaultSort) const",
 "tag": "qtools.tag",
 "url": "d5/d8d/class_q_dir.html#a9439ea6b331957f38dbad981c4d050ef",
 "fragments":[
   "Returns a <span class=\"hl\">list</span> of QFileInfo objects for all files and directories...",
   "... pointer to a QFileInfoList The <span class=\"hl\">list</span> is owned by the QDir object...",
   "... to keep the entries of the <span class=\"hl\">list</span> after a subsequent call to this..."
 ]
},
\end{DoxyVerb}


The fields for such an item have the following meaning\+:
\begin{DoxyItemize}
\item {\itshape type}\+: the type of the item, as found in the field with name \char`\"{}type\char`\"{} in the raw search data.
\item {\itshape name}\+: the name of the item, including the parameter list, as found in the fields with name \char`\"{}name\char`\"{} and \char`\"{}args\char`\"{} in the raw search data.
\item {\itshape tag}\+: the name of the tag file, as found in the field with name \char`\"{}tag\char`\"{} in the raw search data.
\item {\itshape url}\+: the name of the (relative) U\+RL to the documentation, as found in the field with name \char`\"{}url\char`\"{} in the raw search data.
\item \char`\"{}fragments\char`\"{}\+: an array with 0 or more fragments of text containing words that have been search for. These words should be wrapped in {\ttfamily $<$span class=\char`\"{}hl\char`\"{}$>$} and {\ttfamily $<$/span$>$} tags to highlight them in the output. 
\end{DoxyItemize}